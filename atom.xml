<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qill</title>
  <subtitle>Qill</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qiil.github.io/qill.github.io/"/>
  <updated>2017-06-23T09:54:06.747Z</updated>
  <id>https://qiil.github.io/qill.github.io/</id>
  
  <author>
    <name>Qill</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用node做一个基于TCP的聊天程序</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/23/%E7%94%A8node%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/23/用node做一个基于TCP的聊天程序/</id>
    <published>2017-06-23T09:21:01.000Z</published>
    <updated>2017-06-23T09:54:06.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Github项目链接："><a href="#Github项目链接：" class="headerlink" title="Github项目链接："></a>Github项目链接：</h3><p><a href="https://github.com/QiIL/tcp-chat" target="_blank" rel="external">https://github.com/QiIL/tcp-chat</a></p>
<h3 id="程序简介"><a href="#程序简介" class="headerlink" title="程序简介"></a>程序简介</h3><p>首先用到的是 net 模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)</div></pre></td></tr></table></figure></p>
<h3 id="服务器的具体细节："><a href="#服务器的具体细节：" class="headerlink" title="服务器的具体细节："></a>服务器的具体细节：</h3><p>1.有新的成员连接需要需要保存该成员，连接数加1<br>2.监听3000端口<br>3.监听断开连接事件，连接数减1，把该成员移除<br>4.监听输入事件，第一个输入需要输入一个nickname，其他输入视为聊天内容向除了自己意外的所有人推送内容</p>
<p>样例：<br><img src="http://oqzgtjqen.bkt.clouddn.com/tcp-chat1.png" alt=""><br><img src="http://oqzgtjqen.bkt.clouddn.com/tcp-chat2.png" alt=""></p>
<center>完。</center>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Github项目链接：&quot;&gt;&lt;a href=&quot;#Github项目链接：&quot; class=&quot;headerlink&quot; title=&quot;Github项目链接：&quot;&gt;&lt;/a&gt;Github项目链接：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/QiIL/t
    
    </summary>
    
      <category term="Node.js之路" scheme="https://qiil.github.io/qill.github.io/categories/Node-js%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="node" scheme="https://qiil.github.io/qill.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Tiny语言语法树的生成</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/23/Tiny%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/23/Tiny语言语法树的生成/</id>
    <published>2017-06-23T02:01:03.000Z</published>
    <updated>2017-06-23T09:54:44.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>用户按照Tiny语法编辑源程序（打开源程序文件：.tny文件）后生成改程序的语法树。</p>
<h3 id="Github项目连接："><a href="#Github项目连接：" class="headerlink" title="Github项目连接："></a>Github项目连接：</h3><p><a href="https://github.com/QiIL/tiny-Grammar-analysis" target="_blank" rel="external">https://github.com/QiIL/tiny-Grammar-analysis</a></p>
<h3 id="项目中的文件解释"><a href="#项目中的文件解释" class="headerlink" title="项目中的文件解释"></a>项目中的文件解释</h3><ol>
<li>.tny文件：根据文法规则编辑的样例程序</li>
<li>tree.py：定义多子树的树结构</li>
<li>tiny_analisis.py：自上而下的递归子程序分析程序</li>
<li>analisy_gui.py：程序界面相关</li>
</ol>
<h3 id="文法规则"><a href="#文法规则" class="headerlink" title="文法规则"></a>文法规则</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="formula">$ program -&gt; stmt-sequence</span></div><div class="line">$ stmt-sequence -&gt; statement &#123;; statement&#125;</div><div class="line"><span class="formula">$ statement -&gt; if-stmt | repeat-stmt | assign-stmt | read-stmt | write-stmt | return-stmt</span></div><div class="line">$ While-stmt --&gt; while  exp  do  stmt-sequence  endwhile</div><div class="line">Dowhile-stmt--&gt;do  stmt-sequence  while  exp </div><div class="line"><span class="formula">$ for-stmt--&gt;for identifier:=simple-exp  to  simple-exp  do  stmt-sequence enddo    步长递增1</span></div><div class="line">$ for-stmt--&gt;for identifier:=simple-exp  downto  simple-exp  do  stmt-sequence enddo    步长递减1</div><div class="line"><span class="formula">$ if-stmt -&gt; if exp then stmt-sequence [else stmt-sequence] end</span></div><div class="line">$ repeat-stmt -&gt; repeat stmt-sequence until exp</div><div class="line"><span class="formula">$ assign-stmt -&gt; identifier := exp</span></div><div class="line">$ read-stmt -&gt; read identifier</div><div class="line"><span class="formula">$ write-stmt -&gt; write exp</span></div><div class="line">$ return-stmt -&gt; return simple-exp</div><div class="line"><span class="formula">$ exp -&gt; simple-exp [comparison-op simple-exp]</span></div><div class="line">$ comparison-op -&gt; &lt; | =</div><div class="line"><span class="formula">$ simple-exp -&gt; term &#123;addop term&#125;</span></div><div class="line">$ adddop -&gt; + | -</div><div class="line"><span class="formula">$ term -&gt; factor &#123;mulop factor&#125;</span></div><div class="line">$ mulop -&gt; * | /</div><div class="line"><span class="formula">$ factor -&gt; ( exp ) | number | identifier</span></div></pre></td></tr></table></figure>
<h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>使用了tkinter模块，所以请先安装tkinter模块，安装方法（ubuntu16.04）及运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo install python-tk</div><div class="line">$ python analisy_gui.py</div></pre></td></tr></table></figure></p>
<p>程序大概像这样：<br><img src="http://oqzgtjqen.bkt.clouddn.com/2017-06-23%2010-09-33%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<center>完。</center>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h3&gt;&lt;p&gt;用户按照Tiny语法编辑源程序（打开源程序文件：.tny文件）后生成改程序的语法树。&lt;/p&gt;
&lt;h3 id=&quot;Github项目连接：&quot;&gt;&lt;a
    
    </summary>
    
      <category term="算法" scheme="https://qiil.github.io/qill.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="python" scheme="https://qiil.github.io/qill.github.io/tags/python/"/>
    
      <category term="tiny" scheme="https://qiil.github.io/qill.github.io/tags/tiny/"/>
    
      <category term="grammer_tree" scheme="https://qiil.github.io/qill.github.io/tags/grammer-tree/"/>
    
  </entry>
  
  <entry>
    <title>搏击俱乐部-关于精神病的一些思考</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/18/%E6%90%8F%E5%87%BB%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%85%B3%E4%BA%8E%E7%B2%BE%E7%A5%9E%E7%97%85%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/18/搏击俱乐部-关于精神病的一些思考/</id>
    <published>2017-06-18T15:54:10.000Z</published>
    <updated>2017-06-18T16:48:57.099Z</updated>
    
    <content type="html"><![CDATA[<p>我对于这一部分的感受其实比分析每个人的左肩的恶魔与右肩上的天使更深刻。</p>
<p>我回想到自己之前看过一部短片叫《精神分裂》，短片的主角看到了一个陨石砸到了自家的房顶，然后奇怪的事情发生了他的视界与真实偏移了91厘米，在主角的视界中他在真实世界中的身体位置不一样,具体就是这样子的。</p>
<p><center><img src="http://s11.sinaimg.cn/middle/607247fbtb1205948a97a&amp;690" alt=""></center><br>然后他去看医生，医生就当做他是一个异想天开的普通人一样与他聊聊天，主角认为医生并不是很了解他。所以他只好放弃治疗了。</p>
<p>从上帝视角来看，主角并不希望自己变成这个样子，想要变回来，他认为偏移了91厘米让自己的生活出现了极大的混乱，他认为这样子下去他很容易丢掉工作，他不敢让他母亲来探望自己，没事也不敢上街，不敢和他人交流。搏击俱乐部的主角虽然不是是这样子的，但是他拥有双重人格，导演思考角度很好，全篇基本是主角的独白。或许这样是对的，现实中的大多数人的角度去观察这些少数人所总结的事情不一定是正确的，更好的情况是我们能够拥有“上帝视角”，让这些少数人自己叙说他们自己，并且感受到他们的情况才能理解他们罢。</p>
<p>我想到一句话：天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤。但是似乎没那么多人对所谓的大任很有欲望，或许上大街上抓那么几个人做一道选择题：A.假如上天会对你降临一些“灾难”，然后你能够身价多少多少，迎娶白富美。B.你能够平安的健康平庸的的过完你的一生。大多数人的选择会是什么？若是问我，我会回答我选B。</p>
<p>如果说，谁想要一些难题来挑战自己，提升自己，会有很多人说好，来吧。但是，如果把难题和挑战换成病痛呢，说好的，我会觉得你不是傻逼就是真的很有种！</p>
<p>说那么多，不是想说让我们去多多关心生活中的少数人群这种屁话。量子力学的一些周边的理论说，我们不能知道事物真实的样子是什么，我们只能看到我们能看到的东西，我们只能看到一定频段的光谱，只能听到一定频率的声波。但是我们看到的，和听到的就真的是事物原本的样子吗？进化论我们能知道，适者生存这个道理，所以我们想大多数人都是适者，这些少数人不一定是。所以，还是让我们多多关心他们吧:)。</p>
<p>我想和大家分享《精神分裂》这部短片的结局，主角认为只有陨石再来一次才能救他，他等到了第二个陨石，他模仿第一次的时候发生的事情，去陨石附近。陨石掉下来了，当他醒来，他发现，他不仅水平偏移91厘米的问题没有进展，而且垂直方向也偏移了91厘米。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我对于这一部分的感受其实比分析每个人的左肩的恶魔与右肩上的天使更深刻。&lt;/p&gt;
&lt;p&gt;我回想到自己之前看过一部短片叫《精神分裂》，短片的主角看到了一个陨石砸到了自家的房顶，然后奇怪的事情发生了他的视界与真实偏移了91厘米，在主角的视界中他在真实世界中的身体位置不一样,具体就
    
    </summary>
    
      <category term="电影观感" scheme="https://qiil.github.io/qill.github.io/categories/%E7%94%B5%E5%BD%B1%E8%A7%82%E6%84%9F/"/>
    
    
      <category term="fight club" scheme="https://qiil.github.io/qill.github.io/tags/fight-club/"/>
    
  </entry>
  
  <entry>
    <title>搏击俱乐部-与内心邪恶的战争</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/17/%E6%90%8F%E5%87%BB%E4%BF%B1%E4%B9%90%E9%83%A8-%E4%B8%8E%E5%86%85%E5%BF%83%E9%82%AA%E6%81%B6%E7%9A%84%E6%88%98%E4%BA%89/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/17/搏击俱乐部-与内心邪恶的战争/</id>
    <published>2017-06-17T06:59:18.000Z</published>
    <updated>2017-06-20T01:19:59.285Z</updated>
    
    <content type="html"><![CDATA[<p>昨天看完搏击俱乐部，第一感觉很无聊，md 9.0评分的片子这狗样？看完适逢下暴雨下午两三点宿舍就已经天黑了，还有点微微的冷意，加上宿舍奢侈地开着空调还有比这更好的氛围吗，果断睡觉去。一觉直接睡到19.00了，爽得不要不要的。</p>
<p>睡醒之后又想起这部片子了，我记得斌头老师说过一句话，好书永远是你看不懂的书，好电影永远是你看不懂的电影。凡是你看不懂的书那都叫好书，凡是你看不懂的电影都是好电影。所以我想，我智商是不是比别人高那么一点点呢，好像不是。既然世界上那么多人给这部片子高分那它高分就肯定有它的理由嘛。</p>
<p>华丽的分割线（略有剧透）</p>
<hr>
<p>全片就是讲主角与泰勒创造了搏击俱乐部的故事。这句话电影简介有说，其实这句话还是凑个行而已。</p>
<p>真正的正文分割线</p>
<hr>
<p>全片其实是讲主角他自己创建了搏击俱乐部的故事，泰勒是他的另外的人格（个人感觉可以这样说）。主角人设有点类似我们普罗大众，追求优质生活，喜欢展现个性，但又不敢过于张扬的那么一个人。但是这样子并不是他喜欢的，准确地说是主角讨厌这样的生活。主角因为工作关系，他需要经常倒时差，他失眠，焦虑。他其实需要安慰，或者是发泄。</p>
<p>所以他遇到了泰勒，打了他人生的第一次架，然后他觉得很爽，去了一栋报废的楼，泰勒是完全堕落的人，主角并不是，他是有理智的，但是他觉得堕落之后就很爽呀，所以他就在哪里，时不时就去俱乐部打架，白天正常上班。他认为自己能够在白天正常的工作到了其他时间他就可以完全放任自我的日子很爽。恩，很爽吗？我觉得应该是很爽的，从我本身而言。越长大我似乎对越多的东西产生担忧，例如现在我在担忧自己是否能够找得到合适的实习。相比于童年的时候，我也在很多方面有了很多的顾虑，例如我骑车我顾虑会不会撞到别人，会不会破坏公物，会不会摔倒，我敢说我起码前面两条我在童年的时候从来不会是我的顾虑。越是长大会有越多的生活顾虑，这是真的，至于为什么我觉得主角很爽？那是因为我缺乏发泄的平台（或许是我懒得去找一个这样的平台），其实懒并不是原因，更深层的原因是我对很多事物缺乏兴趣，我一直没有真正发自内心的感兴趣过一些事情。所以我认为能放任自我是很爽的事情呢！</p>
<p>肯定有人会说过类似的句子–“每个人都会有自己的阴暗面”。一般来说人都喜欢而且害怕着自己的阴暗面，喜欢是因为自由，害怕则是因为责任。主角在搏击俱乐部的日子就是这样的。当时他内心认为泰勒就是自己想要变成的人。他享受着正常工作和放任自我同时存在的生活，但是影片肯定不会让他那么好过的。泰勒教唆了一堆的极端分子，理性的主角慢慢发现不对劲了，他知道了泰勒就是自己的第二人格而且极端邪恶，他曾经放任的恶魔已经不受控制了。然后主角顺利地走上与恶魔抗争的道路，而且很成功的失败了，从最后的结局来看，他搂着马拉辛格说送她一个礼物时我认为胜利的是泰勒。</p>
<p>这一段本应该有些内容的，不过已经距离看完电影已经两天了，如今已经不知道要写什么了，那就算了罢。</p>
<p>恩，通常来说后面应该跟着一些高中式作文的观点–跟着正义，拒绝邪恶等等，哈哈我就不想写这些东东了。但是对于这部影片却让我想到了之前看过的一部精神病的短片，若是感兴趣不妨移步下一章～</p>
<p>最后补上一句，我现在写文章，我很喜欢口语化，在语句前面加个语气词：恩，额之类的，我觉得在未来的某一天，我回看一定会说这样子看上去很蠢，很low吧（其实现在已经觉得了），但我就是忍不住这么做～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天看完搏击俱乐部，第一感觉很无聊，md 9.0评分的片子这狗样？看完适逢下暴雨下午两三点宿舍就已经天黑了，还有点微微的冷意，加上宿舍奢侈地开着空调还有比这更好的氛围吗，果断睡觉去。一觉直接睡到19.00了，爽得不要不要的。&lt;/p&gt;
&lt;p&gt;睡醒之后又想起这部片子了，我记得斌
    
    </summary>
    
      <category term="电影观感" scheme="https://qiil.github.io/qill.github.io/categories/%E7%94%B5%E5%BD%B1%E8%A7%82%E6%84%9F/"/>
    
    
      <category term="fight club" scheme="https://qiil.github.io/qill.github.io/tags/fight-club/"/>
    
  </entry>
  
  <entry>
    <title>Node事件论调与错误处理</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/12/Node%E4%BA%8B%E4%BB%B6%E8%AE%BA%E8%B0%83%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/12/Node事件论调与错误处理/</id>
    <published>2017-06-12T13:52:56.000Z</published>
    <updated>2017-06-12T14:42:59.610Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，Node出错信息是能够看到堆栈追踪信息的，但是引入事件轮调后就很不一样了例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//test.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	b()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	a()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</div><div class="line">    &#125;, <span class="number">10</span>)</div><div class="line">&#125;</div><div class="line">a()</div></pre></td></tr></table></figure></p>
<p>输出大概像这样（等待1秒）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ node test.js</div><div class="line">throw new Error(<span class="string">'error'</span>)</div><div class="line">Error: error</div><div class="line">    at Timeout._onTimeout (/home/qill/node_learning/test.js:30:9</div><div class="line">)</div><div class="line">    at ontimeout (timers.js:488:11)</div><div class="line">    at tryOnTimeout (timers.js:323:5)</div><div class="line">    at Timer.listOnTimeout (timers.js:283:5)</div></pre></td></tr></table></figure></p>
<p>可以看到是没有堆栈追踪信息输出的。为什么呢，因为想要捕获一个未来才会执行到的函数的错误是不可能的，这会直接抛出未捕获的异常。那么我们就认证一下，是否真的如此<br>我们改一改代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//test.js</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  setTimeout (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    reject(<span class="string">'error'</span>)</div><div class="line">  &#125;, <span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">  <span class="built_in">console</span>.log(err.message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们能够捕获这个异常的话应该会输出 error。运行结果（等待1秒后获得的输出）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ node test.js</div><div class="line">reject(<span class="string">'error'</span>)</div><div class="line">    ^</div><div class="line">ReferenceError: reject is not defined</div><div class="line">    at Timeout.setTimeout [as _onTimeout] (/home/qill/node_learn</div><div class="line">ing/test.js:21:5)</div><div class="line">    at ontimeout (timers.js:488:11)</div><div class="line">    at tryOnTimeout (timers.js:323:5)</div><div class="line">    at Timer.listOnTimeout (timers.js:283:5)</div></pre></td></tr></table></figure></p>
<p>可见仍然是未捕获的异常，catch代码没有运行，因为try，catch是同步的而setTimeout是异步的try并不能捕获未来一秒后的异常。如果想要捕获这个异常要怎么办呢，办法是有的。<br>首先安装这个模块<br><code>$ npm i co</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutError</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>))</div><div class="line">    &#125;, <span class="number">1000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">yield</span> timeoutError()</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(err.message)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>把setTimeout封装成一个promise，然后用co模块去获取promise返回的错误对象，然后输出然后输出这个错误对象的信息就可以了。运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node test.js</div><div class="line">&gt; error</div></pre></td></tr></table></figure></p>
<center>完。</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，Node出错信息是能够看到堆栈追踪信息的，但是引入事件轮调后就很不一样了例如：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
      <category term="Node.js之路" scheme="https://qiil.github.io/qill.github.io/categories/Node-js%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="node" scheme="https://qiil.github.io/qill.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Node单线程的世界</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/12/Node%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/12/Node单线程的世界/</id>
    <published>2017-06-12T08:52:02.000Z</published>
    <updated>2017-06-12T09:29:19.907Z</updated>
    
    <content type="html"><![CDATA[<p>Node 是单线程的。<br>何为单线程： 简单的理解就是，在一个函数执行时，是不可能有第二个函数也在执行的。</p>
<p>证明代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="string">"single_thread.js"</span></div><div class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now()</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5555555555</span>; i++)&#123;&#125;</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</div><div class="line">&#125;, <span class="number">2000</span>);</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node single_thread.js</div><div class="line">&gt; 1009</div><div class="line">&gt; 6597</div></pre></td></tr></table></figure>
<p>首先说明代码要做的事：第一个setTimeout()方法会在1000毫秒后调用回调函数从而执行函数内容–输出调用该函数与开始程序的时间差。第二个setTimeout()方法会在2000毫秒后调用回调函数执行相应函数内容–输出调用该函数与开始程序的时间差。</p>
<p>观察输出可以得到，第一个输出：1009其中9毫秒用在调用函数上，有一点时间上的差别是可以接受的。但是第二个输出：6597就太夸张了，因为，代码设定上他应该输出一个2000毫秒多一点的值才对，但是程序输出的却是一个6000多毫秒的值。为什么？我们不妨从头开始跑一下我们的程序。</p>
<ol>
<li>首先start变量获取到了开始时间。</li>
<li>setTimeout()方法，但是需要等带1000毫秒的回调函数调用</li>
<li>setTimeout()方法，但是需要等待2000毫秒的回调函数调用</li>
<li><strong>距离第一个setTimeout()方法1000毫秒过后，回调函数执行</strong>，输出时间差。</li>
<li>执行第一个函数的for语句</li>
<li>距离第二个setTimeout()方法2000毫秒过后，回调函数执行，<strong>但是上一个setTimeout()方法并没有执行完成，所以回调函数被JavaScript阻塞</strong></li>
<li><strong>当第一个setTimeout()方法中的for语句执行完后，第二个setTimeout()方法的回调函数可以执行了，然后输出时间差</strong></li>
</ol>
<p>由此可见，Node是单线程的（在一个函数执行时，不可能有第二个函数同时也在执行）。</p>
<p>当然了，这样的行为方式是不理想的，事件轮调是Node IO的基础核心。既然超时可以延迟，那HTTP请求以及其他形式的的IO也可以如此。也就意味着，HTTP服务器每秒处理的请求数量减少了，效率也降低了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node 是单线程的。&lt;br&gt;何为单线程： 简单的理解就是，在一个函数执行时，是不可能有第二个函数也在执行的。&lt;/p&gt;
&lt;p&gt;证明代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
    
    </summary>
    
      <category term="Node.js之路" scheme="https://qiil.github.io/qill.github.io/categories/Node-js%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="node" scheme="https://qiil.github.io/qill.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node.js阻塞与非阻塞</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/08/node-js%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/08/node-js阻塞与非阻塞/</id>
    <published>2017-06-08T15:22:30.000Z</published>
    <updated>2017-06-12T08:53:05.606Z</updated>
    
    <content type="html"><![CDATA[<p>首先从区分两段代码开始:</p>
<h3 id="php-代码"><a href="#php-代码" class="headerlink" title="php 代码"></a>php 代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">print</span> (<span class="string">'hello'</span>);</div><div class="line">$ sleep(<span class="number">5</span>);</div><div class="line">$ <span class="keyword">print</span> (<span class="string">'world'</span>);</div><div class="line">$ <span class="keyword">print</span> (<span class="string">'thanks'</span>);</div></pre></td></tr></table></figure>
<h3 id="Node-代码"><a href="#Node-代码" class="headerlink" title="Node 代码"></a>Node 代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</div><div class="line">$ setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'world'</span>)</div><div class="line">&#125;&#125;, <span class="number">5000</span>)</div><div class="line">$ <span class="built_in">console</span>.log(<span class="string">'thanks'</span>)</div></pre></td></tr></table></figure>
<p>第一段脚本会输出：</p>
<blockquote>
<p>hello<br>world<br>thanks</p>
</blockquote>
<p>第二段脚本会输出：</p>
<blockquote>
<p>hello<br>thanks<br>world</p>
</blockquote>
<p>可以看出区别了，Node.js使用了事件论调机制，所以称它是非阻塞的。<br>事件论调意味着，Node会注册事件，然后不断地询问内核这些事件是否已经分发。当事件分发时，对应的回调函数就会触发完成相应事件，然后继续执行后续语句。<br>反观PHP代码中的sleep一旦执行，执行会被阻塞一段时间，并且在阻塞时间未达到设定时间之前是不会有任何操作的，也就是同步的。与阻塞相反，setTimeout只是注册了一个事件，而程序会继续执行，所以这是异步的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先从区分两段代码开始:&lt;/p&gt;
&lt;h3 id=&quot;php-代码&quot;&gt;&lt;a href=&quot;#php-代码&quot; class=&quot;headerlink&quot; title=&quot;php 代码&quot;&gt;&lt;/a&gt;php 代码&lt;/h3&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;
    
    </summary>
    
      <category term="Node.js之路" scheme="https://qiil.github.io/qill.github.io/categories/Node-js%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="node" scheme="https://qiil.github.io/qill.github.io/tags/node/"/>
    
      <category term="io" scheme="https://qiil.github.io/qill.github.io/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04 阿里源</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/06/Ubuntu-16-04-%E9%98%BF%E9%87%8C%E6%BA%90/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/06/Ubuntu-16-04-阿里源/</id>
    <published>2017-06-06T04:52:55.000Z</published>
    <updated>2017-06-07T17:10:53.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">添加阿里云源到如下列表中</div><div class="line">$ sudo vim /etc/apt/sources.list.d/aliyun.list <span class="comment">#修改</span></div><div class="line">更新列表</div><div class="line">$ sudo apt-get update</div></pre></td></tr></table></figure>
<h3 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;操作步骤&quot;&gt;&lt;a href=&quot;#操作步骤&quot; class=&quot;headerlink&quot; title=&quot;操作步骤&quot;&gt;&lt;/a&gt;操作步骤&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
    
    </summary>
    
      <category term="linux琐碎事" scheme="https://qiil.github.io/qill.github.io/categories/linux%E7%90%90%E7%A2%8E%E4%BA%8B/"/>
    
    
      <category term="ubuntu" scheme="https://qiil.github.io/qill.github.io/tags/ubuntu/"/>
    
      <category term="sources.list" scheme="https://qiil.github.io/qill.github.io/tags/sources-list/"/>
    
  </entry>
  
  <entry>
    <title>《情书》读后感</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/06/%E3%80%8A%E6%83%85%E4%B9%A6%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/06/《情书》读后感/</id>
    <published>2017-06-06T03:12:46.000Z</published>
    <updated>2017-06-06T03:22:21.365Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.jiushixing.com/d/file/uploads/allimg/120227/2-12022G51T43K.jpg" alt=""><br>情书给的双线叙事方式，我还是不太习惯去了解吧，或许看书不够状态，所以脑海中的图片跟不上节奏，为什么渡边博子对藤井树这么依恋？藤井见博子第一面就知道两个人很像，藤井树对自己以前的不够勇敢很后悔，所以他一上来就会问博子能做他女朋友吗？</p>
<p>他是一个害怕失去，而且不拘小节的人，但他又是勇敢的，这就是真实的写照吧，人若是体验过失去的滋味，若是上天愿意给第二次机会，试问又有谁不会牢牢把握住呢？对于我来说，若是对于某件事我做出了一个自认为不太好的选择，我之后总会想着要是当时能这样做就好了！但上天不会给自己这么多机会。偏偏藤井树就有这么一次机会，他内心最深处的记忆是一直存在的，所以他勇敢了。</p>
<p>渡子是个怎样的人，我想说，我很希望有这样一个妻子，她对丈夫的爱是忠贞的，是一直忠贞的。虽然之后秋叶在一起，但她就像小溪（to the moon），她的内心很细腻，能记得和爱人的每一个瞬间，每一份感动，每一句话。她不善长表达，她在心底有想法也只会告诉她自已。至于藤井吧，天知道她是怎么被喜欢上的，但青春的柏拉图式的爱情都是这个狗样，他想进办法去吸引她，想迟办法去表达自己的情素，看来是那么傻，那么懵懵懂懂，那么可爱。现实总是这狗样，平时的冤家很有可能在将来会变成CP。个人经验总结一下的话就是：如果传出了感情绯闻，90%的可能不是空穴来风，反正我就是这样。我想着法子去了解我现在的爱人，想当初是那么的笨，那么的可爱，明明对方很明显的心思就是摸不透，我无时无刻不在想着怎么去表白，但似乎想到的都没用上，最多还是在“被迫无耐”下表白了，就像藤井树，天知道他会转学，不然还能多暗恋两年呢。或许他也会想，只要毕业了就上去表白吧～。青春总是没有好戏的，藤井树也选择了一棵比较饱满的麦穗，但他是幸运的，他的麦穗和最大的那稞是差不多的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.jiushixing.com/d/file/uploads/allimg/120227/2-12022G51T43K.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;情书给的双线叙事方式，我还是不太习惯去了解吧，或许看书不够状态，所以脑海中的图片跟
    
    </summary>
    
      <category term="阅读与我" scheme="https://qiil.github.io/qill.github.io/categories/%E9%98%85%E8%AF%BB%E4%B8%8E%E6%88%91/"/>
    
    
  </entry>
  
  <entry>
    <title>python tkFileDialog模块简介</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/06/python-Tkinter%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/06/python-Tkinter图形界面基础/</id>
    <published>2017-06-05T16:43:36.000Z</published>
    <updated>2017-06-05T17:25:10.050Z</updated>
    
    <content type="html"><![CDATA[<p>tkFileDialog是一个通过GUI来实现打开文件或文件加功能的python模块。其用户界面虽然和Win32的很不一样，不过还是挺友好的嘛，还是可以看一看。</p>
<h4>函数简介</h4>

<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>.askopenfile</td>
<td>在指定目录打开相应文件</td>
</tr>
<tr>
<td>.asksaveasfilename</td>
<td>保存文件到指定目录</td>
</tr>
<tr>
<td>.askdirectory</td>
<td>打开一个指定的文件夹</td>
</tr>
</tbody>
</table>
<h4>利用askopenfile打开文件</h4>

<p>askopenfile函数会创建一个文件对话框对象。</p>
<h5>Python2.7版本用法:</h5>

<pre><code>from Tkinter import *from Tkinter import *
import Tkinter, Tkconstants, tkFileDialog

root = Tk()
root.filename = tkFileDialog.askopenfilename(initialdir = &quot;/&quot;,title = &quot;Select file&quot;,filetypes = ((&quot;jpeg files&quot;,&quot;*.jpg&quot;),(&quot;all files&quot;,&quot;*.*&quot;)))
print (root.filename)
</code></pre><h5>Python3本分用法:</h5>

<pre><code>from tkinter import filedialog
from tkinter import *

root = Tk()
root.filename =  filedialog.askopenfilename(initialdir = &quot;/&quot;,title = &quot;Select file&quot;,filetypes = ((&quot;jpeg files&quot;,&quot;*.jpg&quot;),(&quot;all files&quot;,&quot;*.*&quot;)))
print (root.filename)
</code></pre><center><img src="https://pythonspot.com/wp-content/uploads/2015/05/tkfiledialog.jpeg" alt="打开文件对话框"></center>

<h4>利用asksaveasfilename保存文件</h4>

<p>asksaveasfilename提供一个保存文件的对话框</p>
<h5>Python2.7版本用法:</h5>

<pre><code>from Tkinter import *
import Tkinter, Tkconstants, tkFileDialog

root = Tk()
root.filename = tkFileDialog.asksaveasfilename(initialdir = &quot;/&quot;,title = &quot;Select file&quot;,filetypes = ((&quot;jpeg files&quot;,&quot;*.jpg&quot;),(&quot;all files&quot;,&quot;*.*&quot;)))
print (root.filename)
</code></pre><h5>Python3本分用法:</h5>

<pre><code>from tkinter import filedialog
from tkinter import *

root = Tk()
root.filename =  filedialog.asksaveasfilename(initialdir = &quot;/&quot;,title = &quot;Select file&quot;,filetypes = ((&quot;jpeg files&quot;,&quot;*.jpg&quot;),(&quot;all files&quot;,&quot;*.*&quot;)))
print (root.filename)
</code></pre><h4>利用askdirectory打开文件夹</h4>

<h5>Python2.7与Pyhon3用法一样，如下：</h5>

<pre><code>from  Tkinter import *
import Tkinter, Tkconstants, tkFileDialog
root = Tk()
root.directory = tkFileDialog.askdirectory()
print (root.directory)
</code></pre><center><img src="https://pythonspot.com/wp-content/uploads/2015/05/tkinter-askdirectory-e1457134678396.png" alt="打开文件夹对话框"></center>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tkFileDialog是一个通过GUI来实现打开文件或文件加功能的python模块。其用户界面虽然和Win32的很不一样，不过还是挺友好的嘛，还是可以看一看。&lt;/p&gt;
&lt;h4&gt;函数简介&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;
    
    </summary>
    
      <category term="python" scheme="https://qiil.github.io/qill.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://qiil.github.io/qill.github.io/tags/python/"/>
    
      <category term="Tkinter" scheme="https://qiil.github.io/qill.github.io/tags/Tkinter/"/>
    
  </entry>
  
  <entry>
    <title>《to the moon》游玩后有感</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/04/%E3%80%8Ato-the-moon%E3%80%8B%E6%B8%B8%E7%8E%A9%E5%90%8E%E6%9C%89%E6%84%9F/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/04/《to-the-moon》游玩后有感/</id>
    <published>2017-06-04T09:41:40.000Z</published>
    <updated>2017-06-06T03:18:47.444Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.steamstatic.com.8686c.com/steam/apps/206440/ss_1ad788262b8d672b5fd70299320c5c2323ba15ef.1920x1080.jpg" alt=""></p>
<blockquote>
<p>听说 《to the moon》是一款拥有神剧情的游戏。于是我就特意下载来玩一下，游戏只需要三小时，不过三小时已经足够刷新一个人的爱情观了。<br>此文有严重的“剧透”，高能预警～～</p>
</blockquote>
<p>在我看来没有其他方法比解出里面的“谜题”更好了</p>
<h5>故事简介：</h5>

<p>&emsp;&emsp;故事是主角们利用一个记忆改造机的东西去帮助一位即将去世的叫John的老爷爷完成一个去月亮的梦想。主角需要从John的老年-&gt;中年-&gt;青年-&gt;童年一直往下走然后改造John的记忆。把John爷爷从小培养成为了月球而努力的人，从而在长大之后变成一名宇航员然后坐上火箭去月球。主角们在寻找记忆标签的时候有一个很奇怪的现象：John一点都不想去月球！John满脑子只有他亡故的妻子–小溪。。。</p>
<p>去月亮游记的“谜题”：</p>
<h5>兔子，灯塔，鸭嘴兽。</h5>

<p>《序章》</p>
<ol>
<li>为什么JOHN要去月亮？</li>
<li>为什么灯塔上面放了一只兔子？ –听到主题曲《to the moon》</li>
<li>为什么兔子是蓝色加黄色的？</li>
<li>为什么鸭嘴兽在地下室，而且很脏？</li>
</ol>
<h5>ACT 1 其实我一直认为他们是灯塔。</h5>

<ol>
<li>为什么小溪一直闷闷不乐在折兔子，她看着John很烦躁，她不着急吗？</li>
<li>为什么要在这座灯塔附近建屋子？</li>
<li>为什么John喜欢吃腌橄榄？</li>
<li>他们结婚了，但似乎John的母亲有点奇怪。</li>
<li>为什么小溪喜欢看《国王的新衣》？</li>
<li>伊利莎尔是什么样的人，为什么她会说其实她和小溪一样，但她是一个演员？</li>
<li>为什么小溪会直接接受John的约会。</li>
<li>为什么小溪说两个人在同一间放映室看电影就等于一起看电影？不应该坐一起？</li>
<li>为什么John完全没有去月亮的意思？</li>
</ol>
<h5>ACT 2 和 ACT 3基本用来解密了，然后就不用多说了。</h5>

<p>1.John去月亮就是因为想去（或许这样说会有点奇怪但是我认为这应该是没错的），在John一个人的时候，想必他已经把和小溪的点点滴滴回忆了一遍又一遍吧，所以我相信他已经想到了从前，如果我的假设没错的话那么他是回忆了多少次才能够做到不放过这些细节呢？</p>
<p>2&amp;3.我一直认为他们是灯塔，这篇星空下有一只以月亮作为肚子的兔子呢，天是蓝蓝的，月亮也是黄黄的，那么兔子就是蓝色加黄色啦，放在灯塔上估计是John想要告诉小溪他已经知道她不停折兔子时的内心想法了。</p>
<p>4.这是我唯一不知道怎么回答的问题了，如果John已经回忆起所有的东西了，不应该会漏掉鸭嘴兽吧？所以我只能归类为他老了，童年的东西已经不能记得很清楚了（感慨岁月蹉跎），但是鸭嘴兽是陪伴小溪一辈子的玩偶，不可能这都想不到吧？是因为曾经服用药物强制失忆的原因？</p>
<p>5.小溪这是再说我一直记住我和你的童年那个晚上，那个对孤独的有自闭症的小溪无比重要的夜晚，让她认识到友情的夜晚啊！</p>
<p>6.那是因为，小溪想要把所有有关灯塔，月亮，兔子有关的东西都放在身边，然而John只是傻傻的以为小溪只是执着，而且延续这她的奇怪想法。John也是傻得可以，但是反观我们现在，如果我们有John身上那么大的压力的时候，我们还会冷静地站在我们爱的人的角度从对方的角度思考吗？生活差点压垮了John，小溪她自己也非常明白，她觉得很内疚，但天生的性格使她不会向John表达她的想法。</p>
<p>7.John怀念他的哥哥。每个人心中总有点小秘密对吧。。</p>
<p>8.John的母亲也很想念他的哥哥，那个聪明，懂事的哥哥。所以John一直学他的哥哥，他强行改变了自己，他从一个内向的人变成一个开朗，健谈的人了。但他最原始还是内向、保守的，从他只有一个至好的朋友我们就能看到。他其实害怕社交，John也是一个伟大的人呢，试问现在谁还能想他那样把所有的包袱都揽在自己身上呢？</p>
<p>9.初恋信物！！</p>
<p>10.伊利也是内向的人！没错，这是她自己说的，每个人都会有自知之明的，她很明白她与世界是隔绝的，但外部的的“力量”使她更不敢变成像小溪一样的异类！所以她觉得小溪很勇敢–能保持自己，也很幸福–有John的爱情。而她可能每天晚上睡觉之前都会想到自己与世界的孤立，怕会偷偷地哭泣吧，然后第二天醒来又会“开心地”说今天又是新的一天啦，大家要加油喔！！</p>
<p>11.小溪一直就喜欢John啦。。。</p>
<p>12.这我还真不知道是什么意思呢。</p>
<p>13.因为他根本就没有了那个晚上的记忆啦，是两位博士强行开启的记忆，他自己不想要的记忆他怎么会记得呢，如果想要想起小溪，就要先想起哥哥呀，这真是痛苦呢！！这也是要老了之后想开了才敢想起来的事情吧。</p>
<p><center>完。<center><br><img src="http://www.funpcgame.com/images/To-The-Moon-2b.jpg" alt=""></center></center></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.steamstatic.com.8686c.com/steam/apps/206440/ss_1ad788262b8d672b5fd70299320c5c2323ba15ef.1920x1080.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="阅读与我" scheme="https://qiil.github.io/qill.github.io/categories/%E9%98%85%E8%AF%BB%E4%B8%8E%E6%88%91/"/>
    
    
      <category term="to the moon" scheme="https://qiil.github.io/qill.github.io/tags/to-the-moon/"/>
    
  </entry>
  
  <entry>
    <title>scnu毕业生赠字活动观字后感</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/04/scnu%E6%AF%95%E4%B8%9A%E7%94%9F%E8%B5%A0%E5%AD%97%E6%B4%BB%E5%8A%A8%E8%A7%82%E5%AD%97%E5%90%8E%E6%84%9F/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/04/scnu毕业生赠字活动观字后感/</id>
    <published>2017-06-03T16:13:45.000Z</published>
    <updated>2017-06-03T18:10:47.111Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天上完两节课后发现在学校中间广场竟然有一个scnu名家给毕业生赠自的活动。觉得这次学生会的活动挺有意思于是忍不住就去看看，O(∩_∩)O哈哈~差点错过了午饭。</p>
<p>观看了各位老师的作品忍不住想作一评价，纯属个人观点，若是一下老师看到了!那是缘分：）</p>
<p>&emsp;&emsp;雷YK老师，写字思定而后动，字体浓墨重笔，显其苍劲有力。但略显浮华，下笔略有犹豫，不够干脆，行文如挑战，写完一篇松一口大气。看上去就像是修为不太够的样子呢。<br>&emsp;&emsp;余DJ老师，字如作画，专注细节，但胸中未有成文，缺勾缺墨。从字上看，余老师应该是为人随和，粗中有细的人。</p>
<p>&emsp;&emsp;孟DD老师，粗中有细，行云潇洒，一笔成章，然而我在写这篇博文的时候已经对您没印象了，sorry：）</p>
<p>&emsp;&emsp;邝ZB老师，字体苍劲有力，功底深厚，写字时手腕没有一丝抖动，写字之前胸成成竹，行云流水尽显潇洒，看这位老师写字可真是心中舒畅至极。可惜老师周围环境太差，左边有一位一直与邝老师聊天的老师，右边有一位‘不识字’的老师，所以在我看的两个小时左右的时间上邝老师可是一直受到干扰从而有诸多败笔啊。</p>
<p>&emsp;&emsp;邓FM老师，应该是摆摊的老师中文字功底最深厚的老师了。明明如此年长的老师，下笔却是非常干脆，有劲，大字潇洒，不拘一格令我大为赞叹。观赏完大字之后才发现邓老师写的落笔小字更是令我心惊，一笔成章，非常精细。更难得的是，邓老师每一福字都是心无旁骛得写，真是非常用心。</p>
<p>&emsp;&emsp;学生会这个活动对于毕业生们真是有非常大的纪念意义的，辛苦scnu的各位老师了。你们顶着太阳，在北座前面的小广场上为毕业生写了一天的字。我看到了老师对我们的期望，看着师兄师姐拿着字画与老师们拍照留念我不禁想起了以前教过自己的老师，他（她）们在我们毕业的时候内心的对我们的祝福应该也像这些字画，简单而又充满着对莘莘学子的寄托罢。</p>
<center>完。</center>

<p><img src="http://imgmall.artxun.com/images/201008/goods_img/60166_P_1281645214618.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;今天上完两节课后发现在学校中间广场竟然有一个scnu名家给毕业生赠自的活动。觉得这次学生会的活动挺有意思于是忍不住就去看看，O(∩_∩)O哈哈~差点错过了午饭。&lt;/p&gt;
&lt;p&gt;观看了各位老师的作品忍不住想作一评价，纯属个人观点，若是一下老师看到了!那
    
    </summary>
    
      <category term="人生观感" scheme="https://qiil.github.io/qill.github.io/categories/%E4%BA%BA%E7%94%9F%E8%A7%82%E6%84%9F/"/>
    
    
      <category term="书法" scheme="https://qiil.github.io/qill.github.io/tags/%E4%B9%A6%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>GF(2^8)运算一一（二）</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/04/GF-2-8-%E8%BF%90%E7%AE%97%E4%B8%80%E4%B8%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/04/GF-2-8-运算一一（二）/</id>
    <published>2017-06-03T16:06:47.000Z</published>
    <updated>2017-06-03T16:09:05.201Z</updated>
    
    <content type="html"><![CDATA[<p><strong>具体的运算算法</strong><br><strong>加法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//直接异或运算就ok了</div></pre></td></tr></table></figure>
<p><strong>乘法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">unsigned char GFmul(unsigned char a, unsigned char b)&#123;</div><div class="line">	unsigned char result = 0;</div><div class="line">	if ((b&amp;1)==1) result = a;</div><div class="line">	b = b &gt;&gt; 1;</div><div class="line">	for (int i = 0; i &lt; 8; i++)&#123;</div><div class="line">		if ((a&gt;127))</div><div class="line">			a = (a &lt;&lt; 1) ^ 0x1b;</div><div class="line">		else </div><div class="line">			a = a &lt;&lt; 1;</div><div class="line">		if((b&amp;1) == 1)&#123;</div><div class="line">            result ^= a;</div><div class="line">        &#125;</div><div class="line">        b &gt;&gt;= 1;</div><div class="line">	&#125;</div><div class="line">	return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>分析一下乘法原理：</strong><br>总共要循环8次，每一次循环都需要判断b的最低位是否为1，a的最高位是否为1。如果b的最低位为1，那么就结果result就要与a进行异或运算。再判断a最高位是否为1，如果是的话那么a在左移之后还要异或 1B。大概差不多了吧。</p>
<p><strong>乘法逆元：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//生成逆元表函数</div><div class="line">void set_Inverse()&#123;</div><div class="line">	unsigned char gen = 3;</div><div class="line">	Inverse[0] = 0;</div><div class="line">	Inverse[1] = 3;</div><div class="line">	for (int i = 2; i &lt; 256; i++)&#123;</div><div class="line">		Inverse[i] = GFmul(Inverse[i-1], gen);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//查表函数</div><div class="line">unsigned char inverse(unsigned char b)&#123;</div><div class="line">	//初始化 </div><div class="line">	unsigned char result;</div><div class="line">	if (b == 0)&#123;</div><div class="line">		cout &lt;&lt; (int)b &lt;&lt; &quot;没有逆元&quot; &lt;&lt;endl; //0没有逆元</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		for (int i = 1; i &lt; 256; i++)&#123;</div><div class="line">			if (Inverse[i] == b) &#123;</div><div class="line">				result = Inverse[255-i];</div><div class="line">				return result;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>乘法逆元原理：</strong><br>在GF(2^8)这个群里如果有g^x <em> g^y == 1（g是其中一个生成元）那么就会有x+y == 255。回到函数里面，第一个我利用生成元：3做254次乘法（第一个元素是0第二个元素是3）得到了一个以3为生成元重新排列的群。第二个就是查表函数了。暴力搜索出b所在的位置，然后<em>*255-b所在的位置的元素</em></em>就是b的逆元。</p>
<p><strong>离散对数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">void set_genrator()&#123;</div><div class="line">	memset(Genrator, 0, sizeof(Genrator));</div><div class="line">	string buf;</div><div class="line">	int a;</div><div class="line">	ifstream GEN(&quot;一个包含有所有生成元的文件，可以自己生成，也可以上网找&quot;);</div><div class="line">	while (!GEN.eof())&#123;</div><div class="line">		GEN &gt;&gt; buf;</div><div class="line">		a = change_int(buf);</div><div class="line">		Genrator[a] = 1;</div><div class="line">	&#125;</div><div class="line">	GEN.close();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int genrator(unsigned char a, unsigned char b)&#123; </div><div class="line">	if (b == 0)&#123;</div><div class="line">		cout &lt;&lt; (int)b &lt;&lt; &quot;没有离散对数！&quot; &lt;&lt;endl; </div><div class="line">	&#125;</div><div class="line">	else&#123;</div><div class="line">		//多次使用乘法直到找到为止；</div><div class="line">		unsigned char mi = 1; </div><div class="line">		int y = 0;</div><div class="line">		while(1)&#123;</div><div class="line">			mi = GFmul(mi, a); </div><div class="line">			y++;</div><div class="line">			if(mi == b) return y;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>离散对数原理：</strong><br>这里需要用户输入一个“生成元”和一个X，首先要保证用户输入的生成元是一个真实的生成元。所以需要加一个判断。之后就是利用生成元做多次乘法做到值为X为止，循环次数就是离散对数了。</p>
<p><em>最后：仅是学生党随意写的用于交流学习，不喜勿喷，谢谢驻足的各位</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;具体的运算算法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;加法：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://qiil.github.io/qill.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>GF(2^8)运算一一（一）</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/04/GF-2-8-%E8%BF%90%E7%AE%97%E4%B8%80%E4%B8%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/04/GF-2-8-运算一一（一）/</id>
    <published>2017-06-03T16:06:37.000Z</published>
    <updated>2017-06-03T16:08:27.818Z</updated>
    
    <content type="html"><![CDATA[<p>任务:<br>        用C／C++实现对GF(2^8)的若干运算功能，包括：加法、乘法、求乘法逆元（给定x，求y，使得x*y == 1 )、求离散对数（即给定一个生成元g，输入x，求y使得g^y == x)。</p>
<p>首先分析一下思路：<br>加法思路：对每一位进行异或操作</p>
<p>乘法：<br>①（参照密码编码学与网络安全的书本还原的一个算法）首先计算数组a中的对数组b中每一位的乘法中间结果，然后根据数组b决定用来异或的中间结果，最后得出结果。<br>②利用无符号字符类型解释整形创建一个过度变量为result，然后根据字符b的最后一位决定结果值，如果b的最后一位是0则result等于上一个循环的result值，若b的最后一位是1，result值等于result异或a。需要做八次循环，每次循环一开始都要判断a是否大于127如果大于127则a需要左移一位并且异或1B，else a只需要左移一位。</p>
<p>乘法逆元思路：<br>首先规定生成元是3（00000011，当然用其他生成元也可以，随便）然后生成一个以3为生成元的逆元表，然后查询用户输入的x查询到x之后利用255减去x所在位置那个位置的元素即为x的乘法逆元y</p>
<p>离散对数思路：<br>用户输入生成元与X，多次调用乘法，调用乘法的次数则为所求的离散对数</p>
<p>我大概用到的函数定义（忽略界面函数，输入输出函数等与算法无关的函数）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;fstream&gt; </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void set_genrator();           //用于开始设置生成元数组 </div><div class="line">void set_Inverse();           //用于开始设置逆元表</div><div class="line">unsigned char GFsum(unsigned char a, unsigned char b); //求和 </div><div class="line">unsigned char GFmul(unsigned char a, unsigned char b); //乘法 </div><div class="line">unsigned char inverse(unsigned char b);  //乘法逆元 </div><div class="line">bool judge_genrator(unsigned char a); //判断用户输入的生成元是否为生成元 </div><div class="line">int logarithm(unsigned char a, unsigned char b);  //离散对数</div><div class="line">int Genrator[256];           //保存生成元信息</div><div class="line">unsigned char Inverse[256];      //保存以3为生成元的逆元表</div></pre></td></tr></table></figure></p>
<p>用于设置生成元数组用来判断用户输入的生成元是否为一个真实的生成元：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void set_genrator()&#123;</div><div class="line">	memset(Genrator, 0, sizeof(Genrator));</div><div class="line">	string buf;</div><div class="line">	int a;</div><div class="line">	ifstream GEN(&quot;一个包含所有生成元的记录文件，可以自己生成也可以网上去找&quot;);</div><div class="line">	while (!GEN.eof())&#123;</div><div class="line">		GEN &gt;&gt; buf;</div><div class="line">		a = change_int(buf);</div><div class="line">		Genrator[a] = 1;</div><div class="line">	&#125;</div><div class="line">	GEN.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成逆元表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void set_Inverse()&#123;</div><div class="line">	unsigned char gen = 3;</div><div class="line">	Inverse[0] = 0;</div><div class="line">	Inverse[1] = 3;</div><div class="line">	for (int i = 2; i &lt; 256; i++)&#123;</div><div class="line">		Inverse[i] = GFmul(Inverse[i-1], gen);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任务:&lt;br&gt;        用C／C++实现对GF(2^8)的若干运算功能，包括：加法、乘法、求乘法逆元（给定x，求y，使得x*y == 1 )、求离散对数（即给定一个生成元g，输入x，求y使得g^y == x)。&lt;/p&gt;
&lt;p&gt;首先分析一下思路：&lt;br&gt;加法思路：对每一
    
    </summary>
    
    
      <category term="algorithm" scheme="https://qiil.github.io/qill.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下安装gmp一些问题与解决方案</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/04/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85gmp%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/04/ubuntu下安装gmp一些问题与解决方案/</id>
    <published>2017-06-03T16:04:36.000Z</published>
    <updated>2017-06-03T16:05:49.927Z</updated>
    
    <content type="html"><![CDATA[<p>1.ubuntu下安装gmp遇到 configure:error:no usable m4 in$path or /user/5bin解决方案:</p>
<p>其实很简单，是因为你没有m4，安装它就OK了。</p>
<p>sudo apt-get install m4</p>
<p>done.</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.ubuntu下安装gmp遇到 configure:error:no usable m4 in$path or /user/5bin解决方案:&lt;/p&gt;
&lt;p&gt;其实很简单，是因为你没有m4，安装它就OK了。&lt;/p&gt;
&lt;p&gt;sudo apt-get install m4&lt;/p
    
    </summary>
    
      <category term="linux琐碎事" scheme="https://qiil.github.io/qill.github.io/categories/linux%E7%90%90%E7%A2%8E%E4%BA%8B/"/>
    
    
      <category term="ubuntu" scheme="https://qiil.github.io/qill.github.io/tags/ubuntu/"/>
    
      <category term="gmp" scheme="https://qiil.github.io/qill.github.io/tags/gmp/"/>
    
  </entry>
  
  <entry>
    <title>Centos安装python3.5.x与Ipython</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/03/Centos%E5%AE%89%E8%A3%85python3-5-x%E4%B8%8EIpython/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/03/Centos安装python3-5-x与Ipython/</id>
    <published>2017-06-03T15:18:06.000Z</published>
    <updated>2017-06-03T16:01:08.668Z</updated>
    
    <content type="html"><![CDATA[<p>下载源码<br>从python.org下载源码包<br>有一个是tgz结尾的，有一个是tar.xz结尾的随便你下，我下载的是tar.xz<br>Python-3.5.2.tar.xz</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd Python-3.5.2.tar.xz</div></pre></td></tr></table></figure>
<p>在文件夹中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line"></div><div class="line">make</div><div class="line"></div><div class="line">make install #这里要用root权限</div></pre></td></tr></table></figure>
<p>等完就是成功啦，它顺便就帮我安装了pip-8.1.1了呢省下一笔</p>
<p><img src="http://img.blog.csdn.net/20160908200559535" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 --version #就能看到python的版本啦</div></pre></td></tr></table></figure>
<p>接下来是ipython了<br>ipython源码下载页面：<br><a href="https://pypi.python.org/pypi/ipython" target="_blank" rel="external">https://pypi.python.org/pypi/ipython</a><br>或者去Git上下载：<br><a href="https://github.com/ipython/ipython/downloads" target="_blank" rel="external">https://github.com/ipython/ipython/downloads</a><br><img src="http://img.blog.csdn.net/20160908201032567" alt="这里写图片描述"><br>下好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tar -zxvf ipython-5.1.0.tar.gz</div><div class="line"></div><div class="line">cd ipython-5.1.0.tar.gz</div><div class="line"></div><div class="line">python setup.py install</div></pre></td></tr></table></figure>
<p>在终端输入ipython就可以用啦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipython</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160908201922462" alt="这里写图片描述"><br>竟然出来这东东，吓死我了。最后一句说的是缺少一个traitlets这个模块，那就安装呗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install traitlets</div></pre></td></tr></table></figure>
<p>后来又缺少了各种模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install xxx #就行了</div></pre></td></tr></table></figure></p>
<p>安装失败的话还有可能是因为pip的版本不够高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install --upgrade pip #升级一下</div></pre></td></tr></table></figure>
<p>升级有可能会失败的，那就重新安装pip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget https://bootstrap.pypa.io/get-pip.py --no-check-certificate</div><div class="line"></div><div class="line">python3 get-pip.py</div></pre></td></tr></table></figure>
<p>安装了各个模块之后，就可以用啦<img src="http://img.blog.csdn.net/20160908204913538" alt="这里写图片描述"><br>BINGO！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下载源码&lt;br&gt;从python.org下载源码包&lt;br&gt;有一个是tgz结尾的，有一个是tar.xz结尾的随便你下，我下载的是tar.xz&lt;br&gt;Python-3.5.2.tar.xz&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
    
    </summary>
    
      <category term="python" scheme="https://qiil.github.io/qill.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://qiil.github.io/qill.github.io/tags/python/"/>
    
      <category term="Centos" scheme="https://qiil.github.io/qill.github.io/tags/Centos/"/>
    
      <category term="Ipython" scheme="https://qiil.github.io/qill.github.io/tags/Ipython/"/>
    
  </entry>
  
</feed>
