<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qill</title>
  <subtitle>Qill</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qiil.github.io/qill.github.io/"/>
  <updated>2017-06-12T09:25:06.655Z</updated>
  <id>https://qiil.github.io/qill.github.io/</id>
  
  <author>
    <name>Qill</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node单线程的世界</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/12/Node%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/12/Node单线程的世界/</id>
    <published>2017-06-12T08:52:02.000Z</published>
    <updated>2017-06-12T09:25:06.655Z</updated>
    
    <content type="html"><![CDATA[<p>Node 是单线程的。<br>何为单线程： 简单的理解就是，在一个函数执行时，是不可能有第二个函数也在执行的。</p>
<p>证明代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="string">"single_thread.js"</span></div><div class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now()</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5555555555</span>; i++)&#123;&#125;</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</div><div class="line">&#125;, <span class="number">2000</span>);</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node single_thread.js</div><div class="line">&gt; 1009</div><div class="line">&gt; 6597</div></pre></td></tr></table></figure>
<p>首先说明代码要做的事：第一个setTimeout()方法会在1000毫秒后调用回调函数从而执行函数内容–输出调用该函数与开始程序的时间差。第二个setTimeout()方法会在2000毫秒后调用回调函数执行相应函数内容–输出调用该函数与开始程序的时间差。</p>
<p>观察输出可以得到，第一个输出：1009其中9毫秒用在调用函数上，有一点时间上的差别是可以接受的。但是第二个输出：6597就太夸张了，因为，代码设定上他应该输出一个2000毫秒多一点的值才对，但是程序输出的却是一个6000多毫秒的值。为什么？我们不妨从头开始跑一下我们的程序。</p>
<ol>
<li>首先start变量获取到了开始时间。</li>
<li>setTimeout()方法，但是需要等带1000毫秒的回调函数调用</li>
<li>setTimeout()方法，但是需要等待2000毫秒的回调函数调用</li>
<li><strong>距离第一个setTimeout()方法1000毫秒过后，回调函数执行</strong>，输出时间差。</li>
<li>执行第一个函数的for语句</li>
<li>距离第二个setTimeout()方法2000毫秒过后，回调函数执行，<strong>但是上一个setTimeout()方法并没有执行完成，++所以回调函数被JavaScript阻塞++</strong></li>
<li><strong>当第一个setTimeout()方法中的for语句执行完后，第二个setTimeout()方法的回调函数可以执行了，然后输出时间差</strong></li>
</ol>
<p>由此可见，Node是单线程的（在一个函数执行时，不可能有第二个函数同时也在执行）。</p>
<p>当然了，这样的行为方式是不理想的，事件轮调是Node IO的基础核心。既然超时可以延迟，那HTTP请求以及其他形式的的IO也可以如此。也就意味着，HTTP服务器每秒处理的请求数量减少了，效率也降低了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node 是单线程的。&lt;br&gt;何为单线程： 简单的理解就是，在一个函数执行时，是不可能有第二个函数也在执行的。&lt;/p&gt;
&lt;p&gt;证明代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
    
    </summary>
    
      <category term="Node.js之路" scheme="https://qiil.github.io/qill.github.io/categories/Node-js%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="node" scheme="https://qiil.github.io/qill.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node.js阻塞与非阻塞</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/08/node-js%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/08/node-js阻塞与非阻塞/</id>
    <published>2017-06-08T15:22:30.000Z</published>
    <updated>2017-06-12T08:53:05.606Z</updated>
    
    <content type="html"><![CDATA[<p>首先从区分两段代码开始:</p>
<h3 id="php-代码"><a href="#php-代码" class="headerlink" title="php 代码"></a>php 代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">print</span> (<span class="string">'hello'</span>);</div><div class="line">$ sleep(<span class="number">5</span>);</div><div class="line">$ <span class="keyword">print</span> (<span class="string">'world'</span>);</div><div class="line">$ <span class="keyword">print</span> (<span class="string">'thanks'</span>);</div></pre></td></tr></table></figure>
<h3 id="Node-代码"><a href="#Node-代码" class="headerlink" title="Node 代码"></a>Node 代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</div><div class="line">$ setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'world'</span>)</div><div class="line">&#125;&#125;, <span class="number">5000</span>)</div><div class="line">$ <span class="built_in">console</span>.log(<span class="string">'thanks'</span>)</div></pre></td></tr></table></figure>
<p>第一段脚本会输出：</p>
<blockquote>
<p>hello<br>world<br>thanks</p>
</blockquote>
<p>第二段脚本会输出：</p>
<blockquote>
<p>hello<br>thanks<br>world</p>
</blockquote>
<p>可以看出区别了，Node.js使用了事件论调机制，所以称它是非阻塞的。<br>事件论调意味着，Node会注册事件，然后不断地询问内核这些事件是否已经分发。当事件分发时，对应的回调函数就会触发完成相应事件，然后继续执行后续语句。<br>反观PHP代码中的sleep一旦执行，执行会被阻塞一段时间，并且在阻塞时间未达到设定时间之前是不会有任何操作的，也就是同步的。与阻塞相反，setTimeout只是注册了一个事件，而程序会继续执行，所以这是异步的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先从区分两段代码开始:&lt;/p&gt;
&lt;h3 id=&quot;php-代码&quot;&gt;&lt;a href=&quot;#php-代码&quot; class=&quot;headerlink&quot; title=&quot;php 代码&quot;&gt;&lt;/a&gt;php 代码&lt;/h3&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;
    
    </summary>
    
      <category term="Node.js之路" scheme="https://qiil.github.io/qill.github.io/categories/Node-js%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="node" scheme="https://qiil.github.io/qill.github.io/tags/node/"/>
    
      <category term="io" scheme="https://qiil.github.io/qill.github.io/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04 阿里源</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/06/Ubuntu-16-04-%E9%98%BF%E9%87%8C%E6%BA%90/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/06/Ubuntu-16-04-阿里源/</id>
    <published>2017-06-06T04:52:55.000Z</published>
    <updated>2017-06-07T17:10:53.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">添加阿里云源到如下列表中</div><div class="line">$ sudo vim /etc/apt/sources.list.d/aliyun.list <span class="comment">#修改</span></div><div class="line">更新列表</div><div class="line">$ sudo apt-get update</div></pre></td></tr></table></figure>
<h3 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;操作步骤&quot;&gt;&lt;a href=&quot;#操作步骤&quot; class=&quot;headerlink&quot; title=&quot;操作步骤&quot;&gt;&lt;/a&gt;操作步骤&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
    
    </summary>
    
      <category term="linux琐碎事" scheme="https://qiil.github.io/qill.github.io/categories/linux%E7%90%90%E7%A2%8E%E4%BA%8B/"/>
    
    
      <category term="ubuntu" scheme="https://qiil.github.io/qill.github.io/tags/ubuntu/"/>
    
      <category term="sources.list" scheme="https://qiil.github.io/qill.github.io/tags/sources-list/"/>
    
  </entry>
  
  <entry>
    <title>《情书》读后感</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/06/%E3%80%8A%E6%83%85%E4%B9%A6%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/06/《情书》读后感/</id>
    <published>2017-06-06T03:12:46.000Z</published>
    <updated>2017-06-06T03:22:21.365Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.jiushixing.com/d/file/uploads/allimg/120227/2-12022G51T43K.jpg" alt=""><br>情书给的双线叙事方式，我还是不太习惯去了解吧，或许看书不够状态，所以脑海中的图片跟不上节奏，为什么渡边博子对藤井树这么依恋？藤井见博子第一面就知道两个人很像，藤井树对自己以前的不够勇敢很后悔，所以他一上来就会问博子能做他女朋友吗？</p>
<p>他是一个害怕失去，而且不拘小节的人，但他又是勇敢的，这就是真实的写照吧，人若是体验过失去的滋味，若是上天愿意给第二次机会，试问又有谁不会牢牢把握住呢？对于我来说，若是对于某件事我做出了一个自认为不太好的选择，我之后总会想着要是当时能这样做就好了！但上天不会给自己这么多机会。偏偏藤井树就有这么一次机会，他内心最深处的记忆是一直存在的，所以他勇敢了。</p>
<p>渡子是个怎样的人，我想说，我很希望有这样一个妻子，她对丈夫的爱是忠贞的，是一直忠贞的。虽然之后秋叶在一起，但她就像小溪（to the moon），她的内心很细腻，能记得和爱人的每一个瞬间，每一份感动，每一句话。她不善长表达，她在心底有想法也只会告诉她自已。至于藤井吧，天知道她是怎么被喜欢上的，但青春的柏拉图式的爱情都是这个狗样，他想进办法去吸引她，想迟办法去表达自己的情素，看来是那么傻，那么懵懵懂懂，那么可爱。现实总是这狗样，平时的冤家很有可能在将来会变成CP。个人经验总结一下的话就是：如果传出了感情绯闻，90%的可能不是空穴来风，反正我就是这样。我想着法子去了解我现在的爱人，想当初是那么的笨，那么的可爱，明明对方很明显的心思就是摸不透，我无时无刻不在想着怎么去表白，但似乎想到的都没用上，最多还是在“被迫无耐”下表白了，就像藤井树，天知道他会转学，不然还能多暗恋两年呢。或许他也会想，只要毕业了就上去表白吧～。青春总是没有好戏的，藤井树也选择了一棵比较饱满的麦穗，但他是幸运的，他的麦穗和最大的那稞是差不多的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.jiushixing.com/d/file/uploads/allimg/120227/2-12022G51T43K.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;情书给的双线叙事方式，我还是不太习惯去了解吧，或许看书不够状态，所以脑海中的图片跟
    
    </summary>
    
      <category term="阅读与我" scheme="https://qiil.github.io/qill.github.io/categories/%E9%98%85%E8%AF%BB%E4%B8%8E%E6%88%91/"/>
    
    
  </entry>
  
  <entry>
    <title>python tkFileDialog模块简介</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/06/python-Tkinter%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/06/python-Tkinter图形界面基础/</id>
    <published>2017-06-05T16:43:36.000Z</published>
    <updated>2017-06-05T17:25:10.050Z</updated>
    
    <content type="html"><![CDATA[<p>tkFileDialog是一个通过GUI来实现打开文件或文件加功能的python模块。其用户界面虽然和Win32的很不一样，不过还是挺友好的嘛，还是可以看一看。</p>
<h4>函数简介</h4>

<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>.askopenfile</td>
<td>在指定目录打开相应文件</td>
</tr>
<tr>
<td>.asksaveasfilename</td>
<td>保存文件到指定目录</td>
</tr>
<tr>
<td>.askdirectory</td>
<td>打开一个指定的文件夹</td>
</tr>
</tbody>
</table>
<h4>利用askopenfile打开文件</h4>

<p>askopenfile函数会创建一个文件对话框对象。</p>
<h5>Python2.7版本用法:</h5>

<pre><code>from Tkinter import *from Tkinter import *
import Tkinter, Tkconstants, tkFileDialog

root = Tk()
root.filename = tkFileDialog.askopenfilename(initialdir = &quot;/&quot;,title = &quot;Select file&quot;,filetypes = ((&quot;jpeg files&quot;,&quot;*.jpg&quot;),(&quot;all files&quot;,&quot;*.*&quot;)))
print (root.filename)
</code></pre><h5>Python3本分用法:</h5>

<pre><code>from tkinter import filedialog
from tkinter import *

root = Tk()
root.filename =  filedialog.askopenfilename(initialdir = &quot;/&quot;,title = &quot;Select file&quot;,filetypes = ((&quot;jpeg files&quot;,&quot;*.jpg&quot;),(&quot;all files&quot;,&quot;*.*&quot;)))
print (root.filename)
</code></pre><center><img src="https://pythonspot.com/wp-content/uploads/2015/05/tkfiledialog.jpeg" alt="打开文件对话框"></center>

<h4>利用asksaveasfilename保存文件</h4>

<p>asksaveasfilename提供一个保存文件的对话框</p>
<h5>Python2.7版本用法:</h5>

<pre><code>from Tkinter import *
import Tkinter, Tkconstants, tkFileDialog

root = Tk()
root.filename = tkFileDialog.asksaveasfilename(initialdir = &quot;/&quot;,title = &quot;Select file&quot;,filetypes = ((&quot;jpeg files&quot;,&quot;*.jpg&quot;),(&quot;all files&quot;,&quot;*.*&quot;)))
print (root.filename)
</code></pre><h5>Python3本分用法:</h5>

<pre><code>from tkinter import filedialog
from tkinter import *

root = Tk()
root.filename =  filedialog.asksaveasfilename(initialdir = &quot;/&quot;,title = &quot;Select file&quot;,filetypes = ((&quot;jpeg files&quot;,&quot;*.jpg&quot;),(&quot;all files&quot;,&quot;*.*&quot;)))
print (root.filename)
</code></pre><h4>利用askdirectory打开文件夹</h4>

<h5>Python2.7与Pyhon3用法一样，如下：</h5>

<pre><code>from  Tkinter import *
import Tkinter, Tkconstants, tkFileDialog
root = Tk()
root.directory = tkFileDialog.askdirectory()
print (root.directory)
</code></pre><center><img src="https://pythonspot.com/wp-content/uploads/2015/05/tkinter-askdirectory-e1457134678396.png" alt="打开文件夹对话框"></center>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tkFileDialog是一个通过GUI来实现打开文件或文件加功能的python模块。其用户界面虽然和Win32的很不一样，不过还是挺友好的嘛，还是可以看一看。&lt;/p&gt;
&lt;h4&gt;函数简介&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;
    
    </summary>
    
      <category term="python" scheme="https://qiil.github.io/qill.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://qiil.github.io/qill.github.io/tags/python/"/>
    
      <category term="Tkinter" scheme="https://qiil.github.io/qill.github.io/tags/Tkinter/"/>
    
  </entry>
  
  <entry>
    <title>《to the moon》游玩后有感</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/04/%E3%80%8Ato-the-moon%E3%80%8B%E6%B8%B8%E7%8E%A9%E5%90%8E%E6%9C%89%E6%84%9F/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/04/《to-the-moon》游玩后有感/</id>
    <published>2017-06-04T09:41:40.000Z</published>
    <updated>2017-06-06T03:18:47.444Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.steamstatic.com.8686c.com/steam/apps/206440/ss_1ad788262b8d672b5fd70299320c5c2323ba15ef.1920x1080.jpg" alt=""></p>
<blockquote>
<p>听说 《to the moon》是一款拥有神剧情的游戏。于是我就特意下载来玩一下，游戏只需要三小时，不过三小时已经足够刷新一个人的爱情观了。<br>此文有严重的“剧透”，高能预警～～</p>
</blockquote>
<p>在我看来没有其他方法比解出里面的“谜题”更好了</p>
<h5>故事简介：</h5>

<p>&emsp;&emsp;故事是主角们利用一个记忆改造机的东西去帮助一位即将去世的叫John的老爷爷完成一个去月亮的梦想。主角需要从John的老年-&gt;中年-&gt;青年-&gt;童年一直往下走然后改造John的记忆。把John爷爷从小培养成为了月球而努力的人，从而在长大之后变成一名宇航员然后坐上火箭去月球。主角们在寻找记忆标签的时候有一个很奇怪的现象：John一点都不想去月球！John满脑子只有他亡故的妻子–小溪。。。</p>
<p>去月亮游记的“谜题”：</p>
<h5>兔子，灯塔，鸭嘴兽。</h5>

<p>《序章》</p>
<ol>
<li>为什么JOHN要去月亮？</li>
<li>为什么灯塔上面放了一只兔子？ –听到主题曲《to the moon》</li>
<li>为什么兔子是蓝色加黄色的？</li>
<li>为什么鸭嘴兽在地下室，而且很脏？</li>
</ol>
<h5>ACT 1 其实我一直认为他们是灯塔。</h5>

<ol>
<li>为什么小溪一直闷闷不乐在折兔子，她看着John很烦躁，她不着急吗？</li>
<li>为什么要在这座灯塔附近建屋子？</li>
<li>为什么John喜欢吃腌橄榄？</li>
<li>他们结婚了，但似乎John的母亲有点奇怪。</li>
<li>为什么小溪喜欢看《国王的新衣》？</li>
<li>伊利莎尔是什么样的人，为什么她会说其实她和小溪一样，但她是一个演员？</li>
<li>为什么小溪会直接接受John的约会。</li>
<li>为什么小溪说两个人在同一间放映室看电影就等于一起看电影？不应该坐一起？</li>
<li>为什么John完全没有去月亮的意思？</li>
</ol>
<h5>ACT 2 和 ACT 3基本用来解密了，然后就不用多说了。</h5>

<p>1.John去月亮就是因为想去（或许这样说会有点奇怪但是我认为这应该是没错的），在John一个人的时候，想必他已经把和小溪的点点滴滴回忆了一遍又一遍吧，所以我相信他已经想到了从前，如果我的假设没错的话那么他是回忆了多少次才能够做到不放过这些细节呢？</p>
<p>2&amp;3.我一直认为他们是灯塔，这篇星空下有一只以月亮作为肚子的兔子呢，天是蓝蓝的，月亮也是黄黄的，那么兔子就是蓝色加黄色啦，放在灯塔上估计是John想要告诉小溪他已经知道她不停折兔子时的内心想法了。</p>
<p>4.这是我唯一不知道怎么回答的问题了，如果John已经回忆起所有的东西了，不应该会漏掉鸭嘴兽吧？所以我只能归类为他老了，童年的东西已经不能记得很清楚了（感慨岁月蹉跎），但是鸭嘴兽是陪伴小溪一辈子的玩偶，不可能这都想不到吧？是因为曾经服用药物强制失忆的原因？</p>
<p>5.小溪这是再说我一直记住我和你的童年那个晚上，那个对孤独的有自闭症的小溪无比重要的夜晚，让她认识到友情的夜晚啊！</p>
<p>6.那是因为，小溪想要把所有有关灯塔，月亮，兔子有关的东西都放在身边，然而John只是傻傻的以为小溪只是执着，而且延续这她的奇怪想法。John也是傻得可以，但是反观我们现在，如果我们有John身上那么大的压力的时候，我们还会冷静地站在我们爱的人的角度从对方的角度思考吗？生活差点压垮了John，小溪她自己也非常明白，她觉得很内疚，但天生的性格使她不会向John表达她的想法。</p>
<p>7.John怀念他的哥哥。每个人心中总有点小秘密对吧。。</p>
<p>8.John的母亲也很想念他的哥哥，那个聪明，懂事的哥哥。所以John一直学他的哥哥，他强行改变了自己，他从一个内向的人变成一个开朗，健谈的人了。但他最原始还是内向、保守的，从他只有一个至好的朋友我们就能看到。他其实害怕社交，John也是一个伟大的人呢，试问现在谁还能想他那样把所有的包袱都揽在自己身上呢？</p>
<p>9.初恋信物！！</p>
<p>10.伊利也是内向的人！没错，这是她自己说的，每个人都会有自知之明的，她很明白她与世界是隔绝的，但外部的的“力量”使她更不敢变成像小溪一样的异类！所以她觉得小溪很勇敢–能保持自己，也很幸福–有John的爱情。而她可能每天晚上睡觉之前都会想到自己与世界的孤立，怕会偷偷地哭泣吧，然后第二天醒来又会“开心地”说今天又是新的一天啦，大家要加油喔！！</p>
<p>11.小溪一直就喜欢John啦。。。</p>
<p>12.这我还真不知道是什么意思呢。</p>
<p>13.因为他根本就没有了那个晚上的记忆啦，是两位博士强行开启的记忆，他自己不想要的记忆他怎么会记得呢，如果想要想起小溪，就要先想起哥哥呀，这真是痛苦呢！！这也是要老了之后想开了才敢想起来的事情吧。</p>
<p><center>完。<center><br><img src="http://www.funpcgame.com/images/To-The-Moon-2b.jpg" alt=""></center></center></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.steamstatic.com.8686c.com/steam/apps/206440/ss_1ad788262b8d672b5fd70299320c5c2323ba15ef.1920x1080.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="阅读与我" scheme="https://qiil.github.io/qill.github.io/categories/%E9%98%85%E8%AF%BB%E4%B8%8E%E6%88%91/"/>
    
    
      <category term="to the moon" scheme="https://qiil.github.io/qill.github.io/tags/to-the-moon/"/>
    
  </entry>
  
  <entry>
    <title>scnu毕业生赠字活动观字后感</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/04/scnu%E6%AF%95%E4%B8%9A%E7%94%9F%E8%B5%A0%E5%AD%97%E6%B4%BB%E5%8A%A8%E8%A7%82%E5%AD%97%E5%90%8E%E6%84%9F/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/04/scnu毕业生赠字活动观字后感/</id>
    <published>2017-06-03T16:13:45.000Z</published>
    <updated>2017-06-03T18:10:47.111Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天上完两节课后发现在学校中间广场竟然有一个scnu名家给毕业生赠自的活动。觉得这次学生会的活动挺有意思于是忍不住就去看看，O(∩_∩)O哈哈~差点错过了午饭。</p>
<p>观看了各位老师的作品忍不住想作一评价，纯属个人观点，若是一下老师看到了!那是缘分：）</p>
<p>&emsp;&emsp;雷YK老师，写字思定而后动，字体浓墨重笔，显其苍劲有力。但略显浮华，下笔略有犹豫，不够干脆，行文如挑战，写完一篇松一口大气。看上去就像是修为不太够的样子呢。<br>&emsp;&emsp;余DJ老师，字如作画，专注细节，但胸中未有成文，缺勾缺墨。从字上看，余老师应该是为人随和，粗中有细的人。</p>
<p>&emsp;&emsp;孟DD老师，粗中有细，行云潇洒，一笔成章，然而我在写这篇博文的时候已经对您没印象了，sorry：）</p>
<p>&emsp;&emsp;邝ZB老师，字体苍劲有力，功底深厚，写字时手腕没有一丝抖动，写字之前胸成成竹，行云流水尽显潇洒，看这位老师写字可真是心中舒畅至极。可惜老师周围环境太差，左边有一位一直与邝老师聊天的老师，右边有一位‘不识字’的老师，所以在我看的两个小时左右的时间上邝老师可是一直受到干扰从而有诸多败笔啊。</p>
<p>&emsp;&emsp;邓FM老师，应该是摆摊的老师中文字功底最深厚的老师了。明明如此年长的老师，下笔却是非常干脆，有劲，大字潇洒，不拘一格令我大为赞叹。观赏完大字之后才发现邓老师写的落笔小字更是令我心惊，一笔成章，非常精细。更难得的是，邓老师每一福字都是心无旁骛得写，真是非常用心。</p>
<p>&emsp;&emsp;学生会这个活动对于毕业生们真是有非常大的纪念意义的，辛苦scnu的各位老师了。你们顶着太阳，在北座前面的小广场上为毕业生写了一天的字。我看到了老师对我们的期望，看着师兄师姐拿着字画与老师们拍照留念我不禁想起了以前教过自己的老师，他（她）们在我们毕业的时候内心的对我们的祝福应该也像这些字画，简单而又充满着对莘莘学子的寄托罢。</p>
<center>完。</center>

<p><img src="http://imgmall.artxun.com/images/201008/goods_img/60166_P_1281645214618.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;今天上完两节课后发现在学校中间广场竟然有一个scnu名家给毕业生赠自的活动。觉得这次学生会的活动挺有意思于是忍不住就去看看，O(∩_∩)O哈哈~差点错过了午饭。&lt;/p&gt;
&lt;p&gt;观看了各位老师的作品忍不住想作一评价，纯属个人观点，若是一下老师看到了!那
    
    </summary>
    
      <category term="人生观感" scheme="https://qiil.github.io/qill.github.io/categories/%E4%BA%BA%E7%94%9F%E8%A7%82%E6%84%9F/"/>
    
    
      <category term="书法" scheme="https://qiil.github.io/qill.github.io/tags/%E4%B9%A6%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>GF(2^8)运算一一（二）</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/04/GF-2-8-%E8%BF%90%E7%AE%97%E4%B8%80%E4%B8%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/04/GF-2-8-运算一一（二）/</id>
    <published>2017-06-03T16:06:47.000Z</published>
    <updated>2017-06-03T16:09:05.201Z</updated>
    
    <content type="html"><![CDATA[<p><strong>具体的运算算法</strong><br><strong>加法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//直接异或运算就ok了</div></pre></td></tr></table></figure>
<p><strong>乘法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">unsigned char GFmul(unsigned char a, unsigned char b)&#123;</div><div class="line">	unsigned char result = 0;</div><div class="line">	if ((b&amp;1)==1) result = a;</div><div class="line">	b = b &gt;&gt; 1;</div><div class="line">	for (int i = 0; i &lt; 8; i++)&#123;</div><div class="line">		if ((a&gt;127))</div><div class="line">			a = (a &lt;&lt; 1) ^ 0x1b;</div><div class="line">		else </div><div class="line">			a = a &lt;&lt; 1;</div><div class="line">		if((b&amp;1) == 1)&#123;</div><div class="line">            result ^= a;</div><div class="line">        &#125;</div><div class="line">        b &gt;&gt;= 1;</div><div class="line">	&#125;</div><div class="line">	return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>分析一下乘法原理：</strong><br>总共要循环8次，每一次循环都需要判断b的最低位是否为1，a的最高位是否为1。如果b的最低位为1，那么就结果result就要与a进行异或运算。再判断a最高位是否为1，如果是的话那么a在左移之后还要异或 1B。大概差不多了吧。</p>
<p><strong>乘法逆元：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//生成逆元表函数</div><div class="line">void set_Inverse()&#123;</div><div class="line">	unsigned char gen = 3;</div><div class="line">	Inverse[0] = 0;</div><div class="line">	Inverse[1] = 3;</div><div class="line">	for (int i = 2; i &lt; 256; i++)&#123;</div><div class="line">		Inverse[i] = GFmul(Inverse[i-1], gen);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//查表函数</div><div class="line">unsigned char inverse(unsigned char b)&#123;</div><div class="line">	//初始化 </div><div class="line">	unsigned char result;</div><div class="line">	if (b == 0)&#123;</div><div class="line">		cout &lt;&lt; (int)b &lt;&lt; &quot;没有逆元&quot; &lt;&lt;endl; //0没有逆元</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		for (int i = 1; i &lt; 256; i++)&#123;</div><div class="line">			if (Inverse[i] == b) &#123;</div><div class="line">				result = Inverse[255-i];</div><div class="line">				return result;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>乘法逆元原理：</strong><br>在GF(2^8)这个群里如果有g^x <em> g^y == 1（g是其中一个生成元）那么就会有x+y == 255。回到函数里面，第一个我利用生成元：3做254次乘法（第一个元素是0第二个元素是3）得到了一个以3为生成元重新排列的群。第二个就是查表函数了。暴力搜索出b所在的位置，然后<em>*255-b所在的位置的元素</em></em>就是b的逆元。</p>
<p><strong>离散对数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">void set_genrator()&#123;</div><div class="line">	memset(Genrator, 0, sizeof(Genrator));</div><div class="line">	string buf;</div><div class="line">	int a;</div><div class="line">	ifstream GEN(&quot;一个包含有所有生成元的文件，可以自己生成，也可以上网找&quot;);</div><div class="line">	while (!GEN.eof())&#123;</div><div class="line">		GEN &gt;&gt; buf;</div><div class="line">		a = change_int(buf);</div><div class="line">		Genrator[a] = 1;</div><div class="line">	&#125;</div><div class="line">	GEN.close();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int genrator(unsigned char a, unsigned char b)&#123; </div><div class="line">	if (b == 0)&#123;</div><div class="line">		cout &lt;&lt; (int)b &lt;&lt; &quot;没有离散对数！&quot; &lt;&lt;endl; </div><div class="line">	&#125;</div><div class="line">	else&#123;</div><div class="line">		//多次使用乘法直到找到为止；</div><div class="line">		unsigned char mi = 1; </div><div class="line">		int y = 0;</div><div class="line">		while(1)&#123;</div><div class="line">			mi = GFmul(mi, a); </div><div class="line">			y++;</div><div class="line">			if(mi == b) return y;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>离散对数原理：</strong><br>这里需要用户输入一个“生成元”和一个X，首先要保证用户输入的生成元是一个真实的生成元。所以需要加一个判断。之后就是利用生成元做多次乘法做到值为X为止，循环次数就是离散对数了。</p>
<p><em>最后：仅是学生党随意写的用于交流学习，不喜勿喷，谢谢驻足的各位</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;具体的运算算法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;加法：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://qiil.github.io/qill.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>GF(2^8)运算一一（一）</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/04/GF-2-8-%E8%BF%90%E7%AE%97%E4%B8%80%E4%B8%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/04/GF-2-8-运算一一（一）/</id>
    <published>2017-06-03T16:06:37.000Z</published>
    <updated>2017-06-03T16:08:27.818Z</updated>
    
    <content type="html"><![CDATA[<p>任务:<br>        用C／C++实现对GF(2^8)的若干运算功能，包括：加法、乘法、求乘法逆元（给定x，求y，使得x*y == 1 )、求离散对数（即给定一个生成元g，输入x，求y使得g^y == x)。</p>
<p>首先分析一下思路：<br>加法思路：对每一位进行异或操作</p>
<p>乘法：<br>①（参照密码编码学与网络安全的书本还原的一个算法）首先计算数组a中的对数组b中每一位的乘法中间结果，然后根据数组b决定用来异或的中间结果，最后得出结果。<br>②利用无符号字符类型解释整形创建一个过度变量为result，然后根据字符b的最后一位决定结果值，如果b的最后一位是0则result等于上一个循环的result值，若b的最后一位是1，result值等于result异或a。需要做八次循环，每次循环一开始都要判断a是否大于127如果大于127则a需要左移一位并且异或1B，else a只需要左移一位。</p>
<p>乘法逆元思路：<br>首先规定生成元是3（00000011，当然用其他生成元也可以，随便）然后生成一个以3为生成元的逆元表，然后查询用户输入的x查询到x之后利用255减去x所在位置那个位置的元素即为x的乘法逆元y</p>
<p>离散对数思路：<br>用户输入生成元与X，多次调用乘法，调用乘法的次数则为所求的离散对数</p>
<p>我大概用到的函数定义（忽略界面函数，输入输出函数等与算法无关的函数）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;fstream&gt; </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void set_genrator();           //用于开始设置生成元数组 </div><div class="line">void set_Inverse();           //用于开始设置逆元表</div><div class="line">unsigned char GFsum(unsigned char a, unsigned char b); //求和 </div><div class="line">unsigned char GFmul(unsigned char a, unsigned char b); //乘法 </div><div class="line">unsigned char inverse(unsigned char b);  //乘法逆元 </div><div class="line">bool judge_genrator(unsigned char a); //判断用户输入的生成元是否为生成元 </div><div class="line">int logarithm(unsigned char a, unsigned char b);  //离散对数</div><div class="line">int Genrator[256];           //保存生成元信息</div><div class="line">unsigned char Inverse[256];      //保存以3为生成元的逆元表</div></pre></td></tr></table></figure></p>
<p>用于设置生成元数组用来判断用户输入的生成元是否为一个真实的生成元：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void set_genrator()&#123;</div><div class="line">	memset(Genrator, 0, sizeof(Genrator));</div><div class="line">	string buf;</div><div class="line">	int a;</div><div class="line">	ifstream GEN(&quot;一个包含所有生成元的记录文件，可以自己生成也可以网上去找&quot;);</div><div class="line">	while (!GEN.eof())&#123;</div><div class="line">		GEN &gt;&gt; buf;</div><div class="line">		a = change_int(buf);</div><div class="line">		Genrator[a] = 1;</div><div class="line">	&#125;</div><div class="line">	GEN.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成逆元表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void set_Inverse()&#123;</div><div class="line">	unsigned char gen = 3;</div><div class="line">	Inverse[0] = 0;</div><div class="line">	Inverse[1] = 3;</div><div class="line">	for (int i = 2; i &lt; 256; i++)&#123;</div><div class="line">		Inverse[i] = GFmul(Inverse[i-1], gen);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任务:&lt;br&gt;        用C／C++实现对GF(2^8)的若干运算功能，包括：加法、乘法、求乘法逆元（给定x，求y，使得x*y == 1 )、求离散对数（即给定一个生成元g，输入x，求y使得g^y == x)。&lt;/p&gt;
&lt;p&gt;首先分析一下思路：&lt;br&gt;加法思路：对每一
    
    </summary>
    
    
      <category term="algorithm" scheme="https://qiil.github.io/qill.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下安装gmp一些问题与解决方案</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/04/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85gmp%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/04/ubuntu下安装gmp一些问题与解决方案/</id>
    <published>2017-06-03T16:04:36.000Z</published>
    <updated>2017-06-03T16:05:49.927Z</updated>
    
    <content type="html"><![CDATA[<p>1.ubuntu下安装gmp遇到 configure:error:no usable m4 in$path or /user/5bin解决方案:</p>
<p>其实很简单，是因为你没有m4，安装它就OK了。</p>
<p>sudo apt-get install m4</p>
<p>done.</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.ubuntu下安装gmp遇到 configure:error:no usable m4 in$path or /user/5bin解决方案:&lt;/p&gt;
&lt;p&gt;其实很简单，是因为你没有m4，安装它就OK了。&lt;/p&gt;
&lt;p&gt;sudo apt-get install m4&lt;/p
    
    </summary>
    
      <category term="linux琐碎事" scheme="https://qiil.github.io/qill.github.io/categories/linux%E7%90%90%E7%A2%8E%E4%BA%8B/"/>
    
    
      <category term="ubuntu" scheme="https://qiil.github.io/qill.github.io/tags/ubuntu/"/>
    
      <category term="gmp" scheme="https://qiil.github.io/qill.github.io/tags/gmp/"/>
    
  </entry>
  
  <entry>
    <title>Centos安装python3.5.x与Ipython</title>
    <link href="https://qiil.github.io/qill.github.io/2017/06/03/Centos%E5%AE%89%E8%A3%85python3-5-x%E4%B8%8EIpython/"/>
    <id>https://qiil.github.io/qill.github.io/2017/06/03/Centos安装python3-5-x与Ipython/</id>
    <published>2017-06-03T15:18:06.000Z</published>
    <updated>2017-06-03T16:01:08.668Z</updated>
    
    <content type="html"><![CDATA[<p>下载源码<br>从python.org下载源码包<br>有一个是tgz结尾的，有一个是tar.xz结尾的随便你下，我下载的是tar.xz<br>Python-3.5.2.tar.xz</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd Python-3.5.2.tar.xz</div></pre></td></tr></table></figure>
<p>在文件夹中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line"></div><div class="line">make</div><div class="line"></div><div class="line">make install #这里要用root权限</div></pre></td></tr></table></figure>
<p>等完就是成功啦，它顺便就帮我安装了pip-8.1.1了呢省下一笔</p>
<p><img src="http://img.blog.csdn.net/20160908200559535" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 --version #就能看到python的版本啦</div></pre></td></tr></table></figure>
<p>接下来是ipython了<br>ipython源码下载页面：<br><a href="https://pypi.python.org/pypi/ipython" target="_blank" rel="external">https://pypi.python.org/pypi/ipython</a><br>或者去Git上下载：<br><a href="https://github.com/ipython/ipython/downloads" target="_blank" rel="external">https://github.com/ipython/ipython/downloads</a><br><img src="http://img.blog.csdn.net/20160908201032567" alt="这里写图片描述"><br>下好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tar -zxvf ipython-5.1.0.tar.gz</div><div class="line"></div><div class="line">cd ipython-5.1.0.tar.gz</div><div class="line"></div><div class="line">python setup.py install</div></pre></td></tr></table></figure>
<p>在终端输入ipython就可以用啦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipython</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160908201922462" alt="这里写图片描述"><br>竟然出来这东东，吓死我了。最后一句说的是缺少一个traitlets这个模块，那就安装呗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install traitlets</div></pre></td></tr></table></figure>
<p>后来又缺少了各种模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install xxx #就行了</div></pre></td></tr></table></figure></p>
<p>安装失败的话还有可能是因为pip的版本不够高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install --upgrade pip #升级一下</div></pre></td></tr></table></figure>
<p>升级有可能会失败的，那就重新安装pip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget https://bootstrap.pypa.io/get-pip.py --no-check-certificate</div><div class="line"></div><div class="line">python3 get-pip.py</div></pre></td></tr></table></figure>
<p>安装了各个模块之后，就可以用啦<img src="http://img.blog.csdn.net/20160908204913538" alt="这里写图片描述"><br>BINGO！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下载源码&lt;br&gt;从python.org下载源码包&lt;br&gt;有一个是tgz结尾的，有一个是tar.xz结尾的随便你下，我下载的是tar.xz&lt;br&gt;Python-3.5.2.tar.xz&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
    
    </summary>
    
      <category term="python" scheme="https://qiil.github.io/qill.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://qiil.github.io/qill.github.io/tags/python/"/>
    
      <category term="Centos" scheme="https://qiil.github.io/qill.github.io/tags/Centos/"/>
    
      <category term="Ipython" scheme="https://qiil.github.io/qill.github.io/tags/Ipython/"/>
    
  </entry>
  
</feed>
